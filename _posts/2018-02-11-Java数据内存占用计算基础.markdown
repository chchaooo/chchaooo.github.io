---
layout:     post
title:      "java内存占用计算基础"
subtitle:   "内存管理系列基础：能精确计算内存占用，才可以定量判一个模块的内存使用情况是否符合预期"
date:       2018-02-11 20:30:00
author:     "chchaooo"
header-img: "img/main_banner.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 内存
---

# Java内存占用计算基础

## 基本类型占用的内存

Java基本类型占用的字节数：(1字节(byte)=8位(bits))

* 1字节： byte , boolean
* 2字节： short , char
* 4字节： int , float
* 8字节： long , double


## 对象内存的存储方式及所占用内存大小计算

通常，我们谈论的堆内存使用的前提是以“一般情况”为背景的。不包括下面两种情形：

* 某些情况下，JVM根本就没有把Object放入堆中。例如：原则上讲，一个小的thread-local对象存在于栈中，而不是在堆中。
* 被Object占用内存的大小依赖于Object的当前状态。例如：Object的同步锁是否生效，或者，Object是否正在被回收。

我们先来看看在堆中单个的Object长什么样子

![](media/15181658107695/15183204723922.jpg)

在堆中，每个对象由四个域构成（A、B、C 和 D），下面我们逐个解释一下：

* **A**: 对象头，占用很少的字节，表述Object当前状态的信息
* **B**: 基本类型域占用的空间(原生域指 int、boolean、short等)
* **C**: 引用类型域占用的空间(引用类型域指 其他对象的引用，每个引用占用4个字节)
* **D**: 填充物占用的空间(后面说明什么是填充物)

下面我们对A、B、C 和 D 逐一解释

> 内存中，每个对象占用的总空间不仅包含对象内声明的变量所需要的空间，还包括一些额外信息，比如：对象头 和 填充物。

#### A：对象头
**“对象头”的作用是用来记录一个对象的实例名字、ID 和 实例状态**（例如，当前实例是否“可到达”，或者当前锁的状态等等）。

在当前的JVM版本中（Hotspot），“对象头”占用的字节数如下：

* 一个普通对象，占用8 bytes（32位系统为4bytes，64位系统为8bytes）
* 数组，占用 12 bytes，包含普通对象的 8 bytes + 4 bytes（数组长度）

#### B：基本类型

* 1字节： byte , boolean
* 2字节： short , char
* 4字节： int , float
* 8字节： long , double

#### C：引用类型
每个引用类型占用 4 bytes

#### D：填充物
在Hotspot中，每个对象占用的总空间是以8的倍数计算的，对象占用总空间(对象头+声明变量)不足8的倍数时候，自动补齐。而，这些被填充的空间，我们可以称它为“填充物”。我们看下具体实例：

1. 一个空对象（没有声明任何变量）占用 8 bytes -- > 对象头 占用 8 bytes
2. 只声明了一个boolean类型变量的类，占用 16 bytes --> 对象头(8 bytes) + boolean (1 bytes) + 填充物（7 bytes）
3. 声明了8个boolean类型变量的类，占用 16 bytes --> 对象头(8 bytes) + boolean (1 bytes) * 8





