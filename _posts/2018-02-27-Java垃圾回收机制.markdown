---
layout:     post
title:      "(三)java垃圾回收机制"
subtitle:   "理解不同的垃圾回收算法和java虚拟机中垃圾回收机制"
date:       2018-02-28 20:30:00
author:     "chchaooo"
header-img: "img/main_banner.jpg"
header-mask: 0.3
catalog:    true
tags:
    - 内存
---

垃圾收集GC（Garbage Collection）的目的在于清除不再使用的对象。GC通过确定对象是否被活动对象引用来确定是否收集该对象。两种常用的方法是引用计数和对象引用遍历。

### 引用计数收集器

**引用计数**是垃圾收集器中的早期策略。在这种方法中，堆中每个对象（不是引用）都有一个引用计数。当一个对象被创建时，且将该对象分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象+1），但当一个对象的某个引用超过了生命周期或者被设置为一个新值时，对象的引用计数减1。

*任何引用计数为0的对象可以被当作垃圾收集*。当一个对象被垃圾收集时，它引用的任何对象计数减1。

**缺点**： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0（如下图中的Object6,7,8）.

![](https://cl.ly/2d1P3e3R232L/Image%202018-02-25%20at%208.52.42%20%E4%B8%8B%E5%8D%88.png)

### 跟踪收集器

早期的JVM使用引用计数，现在大多数JVM采用对象引用遍历。对象引用遍历从一组对象开始，沿着整个对象图上的每条链接，递归确定可到达（reachable）的对象。如果某对象不能从这些根对象的一个（至少一个）到达，则将它作为垃圾收集。在对象遍历阶段，GC必须记住哪些对象可以到达，以便删除不可到达的对象，这称为标记（marking）对象。

跟踪收集器采用的为集中式的管理方式，全局记录对象之间的引用状态，**执行时从一些列GC  Roots的对象做为起点，从这些节点向下开始进行搜索所有的引用链**，当一个对象到GC  Roots 没有任何引用链时，则证明此对象是不可用的。

如上图中，对象Object6、Object7、Object8虽然互相引用，但他们的GC Roots是不可到达的，所以它们将会被判定为是可回收的对象。

**可作为GC Roots 的对象包括**：
* **虚拟机栈(栈帧中的本地变量表)中的引用对象**
* **方法区中的类静态属性引用的对象**
* **方法区中的常量引用的对象**
* **本地方法栈中JNI的引用对象**

在找到仍然有用的点之后，GC要删除不可到达的对象。

### 常用的垃圾收集算法

**标记－清除算法**
这种算法首先遍历对象图并标记可到达的对象，然后扫描堆栈以寻找未标记对象并释放它们的内存。这种收集器一般使用单线程工作并停止其他操作。并且，由于它只是清除了那些未标记的对象，而并没有对标记对象进行压缩，导致会产生大量内存碎片，从而浪费内存。

**标记－压缩算法**
有时也叫标记－清除－压缩算法，与标记－清除收集器有相同的标记阶段。在第二阶段，则把标记对象复制到堆栈的新域中以便压缩堆栈。这种算法也停止其他操作。

**复制算法**
这种算法将堆栈分为两个域，常称为半空间。每次仅使用一半的空间，JVM生成的新对象则放在另一半空间中。GC运行时，它把可到达对象复制到另一半空间，从而压缩了堆栈。这种方法适用于短生存期的对象，持续复制长生存期的对象则导致效率降低。并且对于指定大小堆来说，需要两倍大小的内存，因为任何时候都只使用其中的一半。

**增量算法**
增量算法把堆栈分为多个域，每次仅从一个域收集垃圾，也可理解为把堆栈分成一小块一小块，每次仅对某一个块进行垃圾收集。这会造成较小的应用程序中断时间，使得用户一般不能觉察到垃圾收集器正在工作。

**分代算法**
复制算法的缺点是：每次收集时，所有的标记对象都要被拷贝，从而导致一些生命周期很长的对象被来回拷贝多次，消耗大量的时间。而分代算法则可解决这个问题。

分代算法把堆栈分为两个或多个域，用以存放不同寿命的对象。JVM生成的新对象一般放在其中的某个域中。过一段时间，继续存在的对象(非短命对象)将获得使用期并转入更长寿命的域中。分代算法对不同的域使用不同的算法以优化性能。
使用垃圾收集器要注意的地方
（1）Java语言允许程序员为任何方法添加finalize( )方法，该方法会在垃圾收集器交换回收对象之前被调用。但不要过分依赖该方法对系统资源进行回收和再利用，因为该方法调用后的执行结果是不可预知的。
（2）垃圾收集器不可以被强制执行，但程序员可以通过调研System.gc方法来建议执行垃圾收集。记住，只是建议。一般不建议自己写System.gc，因为会加大垃圾收集工作量。

