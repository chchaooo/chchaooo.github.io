### Iterable

Iterable接口：实现了该接口的类需要实现iterator()方法,表示当前的数据结构是**可迭代的**。（内部实现迭代器，并对外提供获取迭代器的方法）

下面是Iterable的源代码（只删除了注释）

```java
public interface Iterable<T> {

    Iterator<T> iterator();

    default void forEach(Consumer<? super T> action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
}
```

由于Java的Collection接口实现了Iterable接口，所有所有实现了Collection接口的容器类都必须提供迭代器访问能力。

```
public interface Collection<E> extends Iterable<E> {
```

### Iterator

下面是Iterator的源代码，只删除了注释

```
public interface Iterator<E> {
    boolean hasNext();
    E next();
    default void remove() {
        throw new UnsupportedOperationException("remove");
    }
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

### ListIterator

下面是ListIterator的源代码，只删除了注释

```
public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
}
```
两者的特点

* Iterator：只能向后遍历，只能remove
* ListIterator: 可以双向遍历，增加了add方法

### Something Interesting

比较奇怪和有意思的事情是，从上面的Iterator和ListIterator的源码中可以看到，尽管在Iterator中是有hasNext()方法的，ListIterator扩展自Iterator，但是里面也定义了一个hasNext().从设计上来说，这个并没有太大必要。

![](https://cl.ly/3R0e0z0q3r1r/Image%202018-06-19%20at%203.48.01%20%E4%B8%8B%E5%8D%88.png)

跟同事讨论了下，也确实没找到什么特殊的原因，最后只能简单认为：
ListIterator中这个hasNext()方法可以不定义，这里再次定义一下，只是为了增加可读性，方便查看和理解ListIterator中操作的成对关系（不需要再翻到父类Iterator中才能查看）。

### 附录

* [ConcurrentModificationException](https://chchaooo.github.io/2018/06/11/ConcurrentModificationException/)
* [迭代器模式]()

